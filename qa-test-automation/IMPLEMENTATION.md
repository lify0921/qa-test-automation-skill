# QAテスト自動化スキル - 実装ガイド

このドキュメントは、スキル実行時にClaudeが従うべき詳細な手順を定義します。

## 実装ステップ

### フェーズ0: 差分分析とリスク評価（オプション - 変更差分がある場合）

このフェーズは、コードの変更差分を分析してリスクベーステストを実施する場合に実行します。

#### 0.1 Git差分の取得

```bash
# 最新のコミットとの差分を取得
Bash: git diff HEAD

# 特定のブランチとの差分を取得
Bash: git diff main...feature-branch

# 特定のコミット間の差分を取得
Bash: git diff <commit-hash-1> <commit-hash-2>

# 変更されたファイルのリストを取得
Bash: git diff --name-only HEAD
```

**処理:**
1. ユーザーに比較対象を確認（最新コミット、特定のブランチ、特定のコミットハッシュ）
2. 差分を取得して分析対象を特定
3. 変更されたファイルとその変更内容を記録

#### 0.2 変更内容の分類

各変更を以下のカテゴリに分類：

**変更タイプ:**
- **新機能追加** (New Feature): 新しい機能やエンドポイントの追加
- **バグ修正** (Bug Fix): 既存の不具合の修正
- **リファクタリング** (Refactoring): 機能は変えずにコード構造を改善
- **パフォーマンス改善** (Performance): 性能最適化
- **セキュリティ修正** (Security): 脆弱性の修正
- **ドキュメント** (Documentation): コメントやドキュメントのみの変更

**影響範囲の特定:**
```
変更ファイルごとに以下を記録:
- ファイルパス
- 変更行数（追加/削除）
- 変更された関数/メソッド
- 影響を受ける可能性のある他のモジュール
```

#### 0.3 リスク評価

各変更に対してリスクレベルを評価します。

**リスク評価基準:**

| リスクレベル | 該当する変更 | テスト優先度 |
|------------|------------|------------|
| **Critical** | - 認証・認可ロジックの変更<br>- 決済・金銭処理の変更<br>- データベーススキーマ変更<br>- セキュリティ関連の変更 | 最優先 - 包括的なテストが必須 |
| **High** | - バリデーションロジックの変更<br>- エラーハンドリングの変更<br>- 外部API連携の変更<br>- データ永続化ロジックの変更 | 優先 - 詳細なテストケースを作成 |
| **Medium** | - ビジネスロジックの変更<br>- UIロジックの変更<br>- 新機能の追加<br>- パフォーマンス最適化 | 標準 - 通常のテストケース |
| **Low** | - リファクタリング（動作不変）<br>- ロギング・モニタリングの追加<br>- コメント・ドキュメントのみの変更<br>- コードフォーマットの変更 | 低優先 - 基本的な動作確認 |

**自動リスク判定ロジック:**

```javascript
// 疑似コード例
function assessRisk(change) {
  // Critical Risk
  if (change.affectsAuth || change.affectsPayment || change.affectsSecurity) {
    return 'Critical';
  }

  // High Risk
  if (change.affectsValidation || change.affectsErrorHandling ||
      change.affectsExternalAPI || change.affectsDatabase) {
    return 'High';
  }

  // Medium Risk
  if (change.affectsBusinessLogic || change.isNewFeature) {
    return 'Medium';
  }

  // Low Risk
  if (change.isRefactoring || change.isDocumentationOnly) {
    return 'Low';
  }

  return 'Medium'; // デフォルト
}
```

**キーワードベースの判定:**

以下のキーワードを含む変更は高リスクと判定：

- **Critical**: `auth`, `login`, `password`, `token`, `payment`, `charge`, `transaction`, `admin`, `sudo`, `privilege`
- **High**: `validate`, `sanitize`, `error`, `exception`, `try-catch`, `database`, `query`, `sql`, `api.call`, `fetch`, `axios`
- **Security**: `xss`, `csrf`, `injection`, `escape`, `sanitize`, `encrypt`, `decrypt`, `hash`

#### 0.4 仕様書との照合

変更内容が仕様書と一致しているか確認：

**確認ポイント:**
1. 変更が仕様書に記載された要件に対応しているか
2. 仕様にない変更（想定外の修正）がないか
3. 仕様書で定義されたバリデーションが実装されているか
4. セキュリティ要件が満たされているか

**差異の記録:**
```markdown
## 仕様書との差異

| 変更内容 | 仕様書記載 | 実装状況 | リスク |
|---------|-----------|---------|--------|
| パスワード長の最小値を8→12に変更 | 記載なし | 実装済み | Medium - 仕様書を更新すべき |
| メールアドレスの重複チェック追加 | 要件に記載あり | 実装済み | Low - 要件通り |
| エラーメッセージの変更 | 記載なし | 実装済み | Low |
```

#### 0.5 リスクベーステスト戦略の決定

リスク評価に基づいてテスト戦略を決定：

**Critical Risk → 包括的テスト:**
- すべての正常系・異常系シナリオをカバー
- セキュリティテストを実施
- 境界値テストを徹底
- リグレッションテストを実施

**High Risk → 詳細テスト:**
- 主要な正常系・異常系シナリオをカバー
- エッジケースを考慮
- 関連する既存機能のリグレッションテスト

**Medium Risk → 標準テスト:**
- 基本的な正常系・異常系をカバー
- 主要なユースケースを確認

**Low Risk → 最小限のテスト:**
- 基本的な動作確認のみ
- 既存機能に影響がないことを確認

**出力例:**
```markdown
## リスクベーステスト戦略

### Critical Risk (2件)
1. `src/auth/login.js` - 認証ロジックの変更
   - テスト優先度: 最優先
   - 推奨テスト: 認証バイパステスト、ブルートフォース対策、セッション管理

2. `src/payment/processor.js` - 決済処理の変更
   - テスト優先度: 最優先
   - 推奨テスト: 金額計算の正確性、二重決済防止、エラー時のロールバック

### High Risk (3件)
...

### テスト工数見積:
- Critical: 16時間
- High: 12時間
- Medium: 8時間
- Low: 2時間
- **合計: 38時間**
```

---

### フェーズ1: 情報収集と分析

#### 1.1 仕様書の検索と読み込み

```bash
# 仕様書候補ファイルを検索
Glob: **/*.md, **/spec*.md, **/requirements*.md, **/仕様*.md, **/*.txt
Glob: **/*.pdf (該当する場合)
```

**処理:**
1. 検出されたファイルをリスト化
2. ファイル名とパスからドキュメントタイプを推定
3. ユーザーに確認を求める（複数ある場合）
4. Readツールで内容を読み込み

**抽出すべき情報:**
- システム/機能の目的
- 主要機能一覧
- ユーザーストーリー
- 非機能要件（性能、セキュリティなど）
- 制約事項

#### 1.2 ソースコードの検索と分析

```bash
# 主要なソースコードファイルを検索
Glob: **/*.js, **/*.ts, **/*.py, **/*.java, **/*.cs, **/*.go
```

**処理:**
1. プロジェクト構造を把握
2. 主要なエントリーポイントを特定
3. 関連するモジュール/クラス/関数を識別
4. 依存関係を分析

**分析すべき要素:**
- クラス構造
- 公開API/メソッド
- データフロー
- エラーハンドリング
- バリデーション処理
- 外部サービス連携

#### 1.3 既存のテストコードの確認（存在する場合）

```bash
# 既存のテストファイルを検索
Glob: **/*test*.js, **/*test*.py, **/*spec*.js, **/test_*.py
```

**目的:**
- 既存のテストパターンを理解
- カバレッジの欠落を特定
- テストの命名規則を把握

### フェーズ2: テスト計画の生成

#### 2.1 テスト計画書の構築

**テンプレート読み込み:**
```bash
Read: .claude/skills/qa-test-automation/templates/test_plan_template.md
```

**生成内容:**

1. **目的セクション:**
   - 仕様書から抽出した機能目的を記載
   - テストで検証すべき品質特性を明記

2. **スコープセクション:**
   - **テスト対象:** 仕様書とコードから特定した機能一覧
   - **テスト範囲:** 優先度に基づいて範囲を定義
   - **テスト対象外:** 今回対象外の機能を明記

3. **リソースセクション:**
   - **人的リソース:** 推奨される担当者数とスキルセット
   - **環境リソース:** 必要なテスト環境（開発、ステージング、本番環境など）
   - **ツール:** テスト実行に必要なツール（Selenium、Jest、PyTestなど）

4. **スケジュールセクション:**
   - 各フェーズの工数を推定
   - 機能の複雑さに基づいて期間を算出

5. **品質目標:**
   - コードカバレッジ目標（例: 80%以上）
   - バグ検出率の目標
   - テスト合格基準

6. **リスクと対策:**
   - コードから推測される潜在的なリスク
   - 依存サービスのリスク
   - データ関連のリスク

**出力:**
```bash
Write: test_plan.md
```

### フェーズ3: テスト設計の生成

#### 3.1 テスト観点の抽出

**機能テスト観点:**
- 各機能の正常系シナリオ
- 境界値テスト
- 異常系・エラーハンドリング
- 入力バリデーション

**非機能テスト観点:**
- パフォーマンス（応答時間、スループット）
- セキュリティ（認証、認可、XSS、SQLインジェクションなど）
- ユーザビリティ
- 互換性（ブラウザ、デバイスなど）

#### 3.2 確認項目の作成

**テンプレート読み込み:**
```bash
Read: .claude/skills/qa-test-automation/templates/test_design_template.md
```

**生成ロジック:**

1. **機能ごとに確認項目を列挙**

   例: ログイン機能の場合
   | No. | 確認項目 | テスト技法 | 優先度 |
   |-----|---------|-----------|--------|
   | 1 | 正しい認証情報でログインできる | 正常系 | 高 |
   | 2 | 誤ったパスワードでログインが拒否される | 異常系 | 高 |
   | 3 | 空のフィールドでバリデーションエラーが表示される | 境界値 | 中 |
   | 4 | 3回失敗後にアカウントがロックされる | ビジネスルール | 高 |
   | 5 | SQLインジェクション攻撃が防がれる | セキュリティ | 高 |

2. **テスト技法の選定**
   - 同値分割
   - 境界値分析
   - デシジョンテーブル
   - 状態遷移テスト
   - ユースケーステスト

3. **優先度の設定**
   - 高: ビジネスクリティカルな機能
   - 中: 重要だが代替手段がある機能
   - 低: エッジケース

**出力:**
```bash
Write: test_design.md
```

### フェーズ4: テストケースの生成

#### 4.1 テストケースディレクトリの作成

```bash
Bash: mkdir -p test_cases
```

#### 4.2 各確認項目に対するテストケースの生成

**テンプレート読み込み:**
```bash
Read: .claude/skills/qa-test-automation/templates/test_case_template.md
```

**生成ロジック:**

各確認項目について、以下の形式でテストケースを作成：

**テストケース例（ログイン - 正常系）:**

```markdown
# テストケース

## テストケース情報

| 項目 | 内容 |
|------|------|
| テストケースID | TC001 |
| テストケース名 | 正しい認証情報でログインできることを確認 |
| テスト対象 | ログイン機能 |
| 優先度 | 高 |
| 作成者 | QA自動化スキル |
| 作成日 | 2025-12-25 |

## 前提条件
- テストユーザーアカウントが登録されている
- ユーザー名: testuser@example.com
- パスワード: Test1234!
- ブラウザが起動している
- ログイン画面が表示されている

## テスト手順

| No. | 手順 | 期待結果 |
|-----|------|---------|
| 1 | ユーザー名フィールドに "testuser@example.com" を入力 | 入力された値が表示される |
| 2 | パスワードフィールドに "Test1234!" を入力 | マスクされた文字が表示される |
| 3 | "ログイン" ボタンをクリック | - ダッシュボード画面に遷移<br>- ユーザー名が画面右上に表示される<br>- セッションが確立される |

## テストデータ

### 入力データ

| 項目 | 値 | 備考 |
|------|-----|------|
| ユーザー名 | testuser@example.com | 有効なアカウント |
| パスワード | Test1234! | 正しいパスワード |

### 期待値

| 項目 | 期待値 | 備考 |
|------|--------|------|
| HTTPステータスコード | 200 | 成功 |
| リダイレクトURL | /dashboard | ダッシュボード |
| セッションCookie | 存在する | sessionid |
| 表示ユーザー名 | Test User | 画面右上 |

## 実行結果

| 項目 | 内容 |
|------|------|
| 実行日 | |
| 実行者 | |
| 結果 | [ ] 合格 / [ ] 不合格 |
| 備考 | |

## 不具合情報
<!-- 不具合が発生した場合に記載 -->
```

#### 4.3 テストケースの命名規則

```
test_cases/TC{番号:03d}_{機能名}_{テストシナリオ}.md
```

例:
- `TC001_ログイン_正常系.md`
- `TC002_ログイン_パスワード誤り.md`
- `TC003_ログイン_アカウントロック.md`
- `TC004_ユーザー登録_正常系.md`

#### 4.4 複数テストケースの生成

**処理フロー:**

1. test_design.mdから確認項目一覧を読み込み
2. 各確認項目に対してテストケースを生成
3. テストケースIDを連番で割り当て
4. ファイル名を生成して保存

```bash
# 各テストケースファイルを生成
Write: test_cases/TC001_*.md
Write: test_cases/TC002_*.md
...
```

### フェーズ5: 検証と最終化

#### 5.1 生成されたドキュメントのレビュー

**チェック項目:**
- [ ] すべてのテンプレート項目が埋められている
- [ ] 仕様書の要件が網羅されている
- [ ] テストケースの手順が具体的で実行可能
- [ ] テストデータが適切に定義されている
- [ ] 優先度が適切に設定されている

#### 5.2 サマリーレポートの生成

生成されたドキュメントの概要をユーザーに報告：

```
生成完了サマリー:
- テスト計画書: test_plan.md
- テスト設計書: test_design.md
- テストケース数: 15件
  - 優先度 高: 8件
  - 優先度 中: 5件
  - 優先度 低: 2件
- 対象機能数: 5機能
- 推定工数: 40時間
```

#### 5.3 次のステップの提案

ユーザーに以下を提案：

1. **レビューと調整**
   - 生成されたドキュメントを確認
   - 不足している観点を追加
   - テストデータを実環境に合わせて調整

2. **テスト実装**
   - 自動テストコードの実装（必要に応じて）
   - テスト環境の準備

3. **テスト実行**
   - テストケースに従ったテスト実行
   - 結果の記録

## エラーハンドリング

### ケース1: 仕様書が見つからない

```
対応: ユーザーに仕様書のパスを尋ねる
代替: 既存のREADME.mdやコメントから推測
```

### ケース2: ソースコードが複雑すぎる

```
対応: 主要な機能に絞ってテストを生成
提案: 段階的にテストを追加する方針を提示
```

### ケース3: 技術スタックが不明

```
対応: package.json, requirements.txt, pom.xml などから推測
フォールバック: 汎用的なテストアプローチを採用
```

## カスタマイズポイント

### 1. テンプレートのカスタマイズ

組織の標準に合わせてテンプレートを修正可能：

```bash
# テンプレートの編集
code .claude/skills/qa-test-automation/templates/test_plan_template.md
```

### 2. テスト観点のカスタマイズ

特定の業界やドメインに合わせた観点を追加：

例: 医療系アプリの場合
- HIPAA準拠の確認
- 患者データの暗号化
- 監査ログの記録

### 3. 命名規則のカスタマイズ

組織の命名規則に合わせてファイル名を変更：

```
# 例: Jira連携の場合
TEST-{JIRA番号}_{機能名}.md
```

## パフォーマンス最適化

### 大規模プロジェクトの処理

1. **段階的な生成**
   - 機能ごとに分割して生成
   - 優先度の高い機能から処理

2. **並列処理**
   - 複数のテストケースを並行生成
   - ファイルI/Oの最適化

3. **キャッシング**
   - 仕様書の解析結果をキャッシュ
   - コード構造の分析結果を再利用
